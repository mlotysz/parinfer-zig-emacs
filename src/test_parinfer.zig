/// Test harness for parinfer. Loads JSON test cases and runs them through the algorithm.
const std = @import("std");
const parinfer = @import("parinfer.zig");
const types = @import("types.zig");
const unicode = @import("unicode.zig");
const changes = @import("changes.zig");

const Answer = types.Answer;
const Options = types.Options;
const Change = types.Change;
const Mode = types.Mode;
const Request = types.Request;

// Embed test case files (generated by build.zig, files live outside src/)
const test_data = @import("test_data");
const indent_mode_json = test_data.indent_mode;
const paren_mode_json = test_data.paren_mode;
const smart_mode_json = test_data.smart_mode;

fn getString(value: std.json.Value) ?[]const u8 {
    return switch (value) {
        .string => |s| s,
        else => null,
    };
}

fn getInt(value: std.json.Value) ?i64 {
    return switch (value) {
        .integer => |n| n,
        else => null,
    };
}

fn getBool(value: std.json.Value) ?bool {
    return switch (value) {
        .bool => |b| b,
        else => null,
    };
}

fn getObject(value: std.json.Value) ?std.json.ObjectMap {
    return switch (value) {
        .object => |o| o,
        else => null,
    };
}

fn getArray(value: std.json.Value) ?std.json.Array {
    return switch (value) {
        .array => |a| a,
        else => null,
    };
}

fn isNonClojureCase(options_val: std.json.Value) bool {
    const opts = getObject(options_val) orelse return false;
    // Skip cases that use non-Clojure language features
    if (opts.get("lispVlineSymbols")) |v| {
        if (getBool(v) orelse false) return true;
    }
    if (opts.get("lispBlockComments")) |v| {
        if (getBool(v) orelse false) return true;
    }
    if (opts.get("guileBlockComments")) |v| {
        if (getBool(v) orelse false) return true;
    }
    if (opts.get("schemeSexpComments")) |v| {
        if (getBool(v) orelse false) return true;
    }
    if (opts.get("janetLongStrings")) |v| {
        if (getBool(v) orelse false) return true;
    }
    return false;
}

fn parseChanges(allocator: std.mem.Allocator, changes_val: std.json.Value) ![]Change {
    const arr = getArray(changes_val) orelse return &.{};
    var result = try allocator.alloc(Change, arr.items.len);
    for (arr.items, 0..) |item, i| {
        const obj = getObject(item) orelse continue;
        result[i] = Change{
            .line_no = @intCast(getInt(obj.get("lineNo") orelse continue) orelse continue),
            .x = @intCast(getInt(obj.get("x") orelse continue) orelse continue),
            .old_text = getString(obj.get("oldText") orelse continue) orelse continue,
            .new_text = getString(obj.get("newText") orelse continue) orelse continue,
        };
    }
    return result;
}

fn runTestCases(json_data: []const u8, mode: Mode) !void {
    const allocator = std.testing.allocator;

    var parsed = try std.json.parseFromSlice(std.json.Value, allocator, json_data, .{});
    defer parsed.deinit();

    const cases = getArray(parsed.value) orelse return error.InvalidJson;

    var passed: usize = 0;
    var skipped: usize = 0;
    var failed: usize = 0;

    for (cases.items) |case_val| {
        const case_obj = getObject(case_val) orelse continue;

        const text = getString(case_obj.get("text") orelse continue) orelse continue;
        const options_val = case_obj.get("options") orelse continue;

        // Skip non-Clojure cases
        if (isNonClojureCase(options_val)) {
            skipped += 1;
            continue;
        }

        const result_obj = getObject(case_obj.get("result") orelse continue) orelse continue;
        const expected_text = getString(result_obj.get("text") orelse continue) orelse continue;
        const expected_success = getBool(result_obj.get("success") orelse continue) orelse continue;

        // Get source line number for error messages
        const source_obj = getObject(case_obj.get("source") orelse continue) orelse continue;
        const source_line = getInt(source_obj.get("lineNo") orelse continue) orelse 0;

        // Parse options
        const opts_obj = getObject(options_val) orelse std.json.ObjectMap.init(allocator);
        var options = Options{};

        if (opts_obj.get("cursorX")) |v| {
            if (getInt(v)) |n| options.cursor_x = @intCast(n);
        }
        if (opts_obj.get("cursorLine")) |v| {
            if (getInt(v)) |n| options.cursor_line = @intCast(n);
        }
        if (opts_obj.get("prevCursorX")) |v| {
            if (getInt(v)) |n| options.prev_cursor_x = @intCast(n);
        }
        if (opts_obj.get("prevCursorLine")) |v| {
            if (getInt(v)) |n| options.prev_cursor_line = @intCast(n);
        }

        // Use an arena for each test case so all internal parinfer allocations
        // are cleaned up together (avoids false-positive leak reports from the GPA
        // when ArrayList backing memory moves between State fields).
        var arena = std.heap.ArenaAllocator.init(allocator);
        defer arena.deinit();
        const case_allocator = arena.allocator();

        // Parse changes
        if (opts_obj.get("changes")) |changes_val| {
            options.changes = try parseChanges(case_allocator, changes_val);
        }

        const request = Request{
            .mode = mode,
            .text = text,
            .options = options,
        };

        const answer = parinfer.process(case_allocator, &request) catch |err| {
            std.debug.print("FAIL case line {d}: process returned error: {any}\n", .{ source_line, err });
            failed += 1;
            continue;
        };

        // Check success
        if (answer.success != expected_success) {
            std.debug.print("FAIL case line {d}: success: expected {}, got {}\n", .{ source_line, expected_success, answer.success });
            failed += 1;
            continue;
        }

        // Check text
        if (!std.mem.eql(u8, answer.text, expected_text)) {
            std.debug.print("FAIL case line {d}: text mismatch\n  expected: \"{s}\"\n  got:      \"{s}\"\n", .{ source_line, expected_text, answer.text });
            failed += 1;
            continue;
        }

        // Check cursor if expected
        if (result_obj.get("cursorX")) |v| {
            if (getInt(v)) |expected_cx| {
                const actual_cx: ?i64 = if (answer.cursor_x) |cx| @intCast(cx) else null;
                if (actual_cx != expected_cx) {
                    std.debug.print("FAIL case line {d}: cursorX: expected {d}, got {?d}\n", .{ source_line, expected_cx, actual_cx });
                    failed += 1;
                    continue;
                }
            }
        }
        if (result_obj.get("cursorLine")) |v| {
            if (getInt(v)) |expected_cl| {
                const actual_cl: ?i64 = if (answer.cursor_line) |cl| @intCast(cl) else null;
                if (actual_cl != expected_cl) {
                    std.debug.print("FAIL case line {d}: cursorLine: expected {d}, got {?d}\n", .{ source_line, expected_cl, actual_cl });
                    failed += 1;
                    continue;
                }
            }
        }

        // Check error if expected
        if (result_obj.get("error")) |err_val| {
            if (getObject(err_val)) |err_obj| {
                if (answer.err) |actual_err| {
                    if (err_obj.get("name")) |v| {
                        if (getString(v)) |expected_name| {
                            if (!std.mem.eql(u8, actual_err.name.toString(), expected_name)) {
                                std.debug.print("FAIL case line {d}: error.name: expected \"{s}\", got \"{s}\"\n", .{ source_line, expected_name, actual_err.name.toString() });
                                failed += 1;
                                continue;
                            }
                        }
                    }
                    if (err_obj.get("lineNo")) |v| {
                        if (getInt(v)) |expected_line| {
                            if (@as(i64, @intCast(actual_err.line_no)) != expected_line) {
                                std.debug.print("FAIL case line {d}: error.lineNo: expected {d}, got {d}\n", .{ source_line, expected_line, actual_err.line_no });
                                failed += 1;
                                continue;
                            }
                        }
                    }
                    if (err_obj.get("x")) |v| {
                        if (getInt(v)) |expected_x| {
                            if (@as(i64, @intCast(actual_err.x)) != expected_x) {
                                std.debug.print("FAIL case line {d}: error.x: expected {d}, got {d}\n", .{ source_line, expected_x, actual_err.x });
                                failed += 1;
                                continue;
                            }
                        }
                    }
                } else {
                    std.debug.print("FAIL case line {d}: expected error but got none\n", .{source_line});
                    failed += 1;
                    continue;
                }
            }
        }

        // Check tab stops if expected
        if (result_obj.get("tabStops")) |ts_val| {
            if (getArray(ts_val)) |expected_stops| {
                if (answer.tab_stops.len != expected_stops.items.len) {
                    std.debug.print("FAIL case line {d}: tab stop count: expected {d}, got {d}\n", .{ source_line, expected_stops.items.len, answer.tab_stops.len });
                    failed += 1;
                    continue;
                }
                var tab_ok = true;
                for (expected_stops.items, 0..) |stop_val, si| {
                    const stop_obj = getObject(stop_val) orelse continue;
                    const actual = answer.tab_stops[si];
                    if (stop_obj.get("x")) |v| {
                        if (getInt(v)) |ex| {
                            if (@as(i64, @intCast(actual.x)) != ex) {
                                std.debug.print("FAIL case line {d}: tab_stop[{d}].x: expected {d}, got {d}\n", .{ source_line, si, ex, actual.x });
                                tab_ok = false;
                            }
                        }
                    }
                    if (stop_obj.get("lineNo")) |v| {
                        if (getInt(v)) |el| {
                            if (@as(i64, @intCast(actual.line_no)) != el) {
                                std.debug.print("FAIL case line {d}: tab_stop[{d}].lineNo: expected {d}, got {d}\n", .{ source_line, si, el, actual.line_no });
                                tab_ok = false;
                            }
                        }
                    }
                    if (stop_obj.get("ch")) |v| {
                        if (getString(v)) |ech| {
                            if (ech.len > 0 and actual.ch != ech[0]) {
                                std.debug.print("FAIL case line {d}: tab_stop[{d}].ch: expected '{c}', got '{c}'\n", .{ source_line, si, ech[0], actual.ch });
                                tab_ok = false;
                            }
                        }
                    }
                    if (stop_obj.get("argX")) |v| {
                        const expected_ax: ?i64 = getInt(v);
                        const actual_ax: ?i64 = if (actual.arg_x) |ax| @intCast(ax) else null;
                        if (expected_ax != actual_ax) {
                            std.debug.print("FAIL case line {d}: tab_stop[{d}].argX: expected {?d}, got {?d}\n", .{ source_line, si, expected_ax, actual_ax });
                            tab_ok = false;
                        }
                    }
                }
                if (!tab_ok) {
                    failed += 1;
                    continue;
                }
            }
        }

        // Check paren trails if expected
        if (result_obj.get("parenTrails")) |pt_val| {
            if (getArray(pt_val)) |expected_trails| {
                if (answer.paren_trails.len != expected_trails.items.len) {
                    std.debug.print("FAIL case line {d}: paren trail count: expected {d}, got {d}\n", .{ source_line, expected_trails.items.len, answer.paren_trails.len });
                    failed += 1;
                    continue;
                }
                var trails_ok = true;
                for (expected_trails.items, 0..) |trail_val, ti| {
                    const trail_obj = getObject(trail_val) orelse continue;
                    const actual = answer.paren_trails[ti];
                    if (trail_obj.get("lineNo")) |v| {
                        if (getInt(v)) |el| {
                            if (@as(i64, @intCast(actual.line_no)) != el) {
                                std.debug.print("FAIL case line {d}: paren_trail[{d}].lineNo: expected {d}, got {d}\n", .{ source_line, ti, el, actual.line_no });
                                trails_ok = false;
                            }
                        }
                    }
                    if (trail_obj.get("startX")) |v| {
                        if (getInt(v)) |es| {
                            if (@as(i64, @intCast(actual.start_x)) != es) {
                                std.debug.print("FAIL case line {d}: paren_trail[{d}].startX: expected {d}, got {d}\n", .{ source_line, ti, es, actual.start_x });
                                trails_ok = false;
                            }
                        }
                    }
                    if (trail_obj.get("endX")) |v| {
                        if (getInt(v)) |ee| {
                            if (@as(i64, @intCast(actual.end_x)) != ee) {
                                std.debug.print("FAIL case line {d}: paren_trail[{d}].endX: expected {d}, got {d}\n", .{ source_line, ti, ee, actual.end_x });
                                trails_ok = false;
                            }
                        }
                    }
                }
                if (!trails_ok) {
                    failed += 1;
                    continue;
                }
            }
        }

        passed += 1;
    }

    std.debug.print("  Passed: {d}, Skipped: {d}, Failed: {d}\n", .{ passed, skipped, failed });

    if (failed > 0) {
        return error.TestsFailed;
    }
}

test "indent mode" {
    std.debug.print("\n=== Indent Mode Tests ===\n", .{});
    try runTestCases(indent_mode_json, .indent);
}

test "paren mode" {
    std.debug.print("\n=== Paren Mode Tests ===\n", .{});
    try runTestCases(paren_mode_json, .paren);
}

test "smart mode" {
    std.debug.print("\n=== Smart Mode Tests ===\n", .{});
    try runTestCases(smart_mode_json, .smart);
}

// Unicode-specific tests
test "composed unicode graphemes count as single character" {
    const allocator = std.testing.allocator;
    const request = Request{
        .mode = .paren,
        .text = "(éééé (\nh))",
        .options = .{},
    };
    const answer = try parinfer.process(allocator, &request);
    defer parinfer.freeAnswer(allocator, &answer);
    try std.testing.expect(answer.success);
    try std.testing.expectEqualStrings("(éééé (\n       h))", answer.text);
}

test "wide characters" {
    const allocator = std.testing.allocator;
    const request = Request{
        .mode = .smart,
        .text = "(def ｗｏｒｌｄ {:foo 1\n            :bar 2})",
        .options = .{
            .cursor_x = 12,
            .cursor_line = 1,
            .changes = &.{Change{
                .line_no = 0,
                .x = 5,
                .old_text = "world",
                .new_text = "ｗｏｒｌｄ",
            }},
        },
    };
    const answer = try parinfer.process(allocator, &request);
    defer parinfer.freeAnswer(allocator, &answer);
    try std.testing.expect(answer.success);
    try std.testing.expectEqualStrings("(def ｗｏｒｌｄ {:foo 1\n                 :bar 2})", answer.text);
}

// Also pull in tests from other modules
comptime {
    _ = @import("unicode.zig");
    _ = @import("changes.zig");
}
